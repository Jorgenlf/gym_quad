import numpy as np
import math
'''
FORMAT:
# PERFORMANCE METRICS (LAST 100 EPISODES AVG.)
Episodes                      100                           
Avg. Reward                   -2133.49                      
Std. Reward                   976.65                        
Avg. Progress                 21.28%                        
Avg. Collisions               0.05                          
No Collisions                 95.00%                        
Avg. Cross-Track Error        60.21                         
Avg. Timesteps                2100.16                       
Avg. Duration                 2100.16                       
Avg. Pathlength               963.05                        
Avg. Speed                    0.67                          
Max. Speed                    3.39         # DOES NOT TAKE COLLISION INTO ACCOUNT
'''


def read_report(path, convert_percentages=False):
    with open(path, 'r') as f:
        _f = f.read()

    score_list = _f.split(sep="\n")
    score_list = score_list[1:-1]  # Discard title and trailing newline character

    # Construct dictionary of scores:
    agent_scores = dict()
    for i, line in enumerate(score_list):
        score = line[30:]  # Format: '{:<30}{:<30.2f}' -- {30pts attribute}{the rest is score}
        if '%' in score:
            score = score.replace('%', '')  # Remove % from string to enable conversion to float.

        score = float(score)

        if not convert_percentages:
            agent_scores[ATTRIBUTES[i]] = score

        else:
            if ATTRIBUTES[i] == "Avg. Timesteps":
                agent_scores[ATTRIBUTES[i]] = 100 - 100*score/10000

            elif ATTRIBUTES[i] == "Avg. Cross-Track Error":
                # Normalize to range 0-1 based on collected data. min:5.22, max:186.85
                # norm_score = (score - 5.22) / (186.85 - 5.22)
                norm_score = (score - 0.37) / (609.16 - 0.37)  # Normalizes exactly as the previous experiment
                agent_scores[ATTRIBUTES[i]] = 100 - 100*norm_score  # 100 - 0.5 * np.min((score, 200))  # 100/np.max((np.log10(score), 1))
            else:
                agent_scores[ATTRIBUTES[i]] = score

    return agent_scores


def performance(params, normalize=True):
    '''
    Args:
        params: Dictionary containing the reporting attributes generated by gym-auv reporting.py
        normalize: True - set False if this function is used to calculate Usability.

    Returns:
        The "performance" metric, as specified in Halvor Teigen's pre-project.
    '''
    p = 1 / (1 + math.pow(1.1, -0.02*params["Avg. Reward"]-50)) + \
        1 / (1 + np.exp(8-0.15*params["Avg. Progress"])) + \
        math.pow(1.1, -params["Avg. Collisions"]) + \
        math.pow(1.05, -0.04*params["Avg. Cross-Track Error"])

    if normalize:
        p = 100 * p / 4  # Normalize to percentage.

    return p


def usability(params, hours):
    '''
        Args:
            params: Dictionary containing the reporting attributes generated by gym-auv reporting.py
            hours: Wall-time consumption before the algorithm completed 1.5M time steps.

        Returns:
            The "usability" metric, as specified in Halvor Teigen's pre-project.
        '''
    u = performance(params, normalize=False) + (1 / (1 + np.exp(0.5*hours - 4)))

    u = 100 * u / 5  # Normalize to percentage.
    return u


def plot_progress_vs_env(reports, show=True):
    # Format data to plot
    plt.style.use('ggplot')
    plt.rc('font', family='serif')
    # plt.rc('font', family='serif', serif='Times')
    # plt.rc('text', usetex=True)
    plt.rc('xtick', labelsize=11)
    plt.rc('ytick', labelsize=11)
    plt.rc('axes', labelsize=11)
    plt.axis('scaled')

    algos = ['ppo', 'ddpg', 'td3', 'sac']
    algo_idx = [0, 1, 2, 3]
    colors = ['#1aaf6c', '#429bf4', '#d42cea', '#fa8638']
    patterns = ["\\", "/", ".", "o"] #, "O"]
    # Helper function
    def get_values(algo, env):
        # Fetch the performance attributes for ALGO in the report
        values = reports[algo][env]["Avg. Progress"]
        return values

    offsets = [-0.3, -0.1, 0.1, 0.3]
    width = 0.2
    envs = np.array([0, 1, 2, 3])
    env_names = ["MovingObstaclesNoRules", "Trondheim", "Agdenes", "Sorbuoya"]
    #env_names = ["Env0", "Env1", "Env2", "Env3", "Env4", "MovingObstaclesNoRules"]

    fig, ax = plt.subplots(1, figsize=(15,5))
    for algo in algo_idx:
        values = []
        for env in envs:
            values.append(get_values(algos[algo], env))

        ax.bar(envs + offsets[algo], values, width=width, color=colors[algo], edgecolor="black", hatch=patterns[algo],
               label=algos[algo].upper())


    plt.xticks(envs, env_names)
    plt.legend(prop={'size': 13})
    ax.set_xlabel("Environments", size=13)
    ax.set_ylabel("Avg. Progress [%]", size=13)
    plt.tight_layout()
    if show:
        plt.show()

def plot_attribute_per_env(ax, algo, reports, attributes=None, show=False):

    if attributes is None:
        attributes = ATTRIBUTES
    else:
        attributes = [attributes]

    for attr in attributes:
        x = []
        y = []
        for env in reports:
            x.append(env["Environment"])
            y.append(env[attr])

        ax.plot(x,y, label=algo)
        ax.legend()
        ax.set_xlabel("Environments")
        ax.set_ylabel(attr + " [%]")
        #plt.xticks(rotation=5)
        #plt.title("Training Performance")
        #plt.title(attr)

        if show:
            plt.show()

def plot_attribute_per_algo(reports, env=None, attributes=None, show=False):

    if attributes is None:
        attributes = ["Avg. Progress", "No Collisions", "Avg. Timesteps", "Avg. Cross-Track Error", "Avg. Reward"]
    else:
        attributes = [attributes]

    fig, ax = plt.subplots(1,len(attributes), figsize=(20,5))
    for i, attr in enumerate(attributes):
        x = []
        y = []
        for algo in reports:
            if reports[algo] == []:
                continue
            x.append(algo.upper())
            y.append(reports[algo][0][attr])

        ax[i].bar(x,y)
        #ax[i].set_xlabel("RL algoritms")
        ax[i].set_ylabel(attr)
        #plt.xticks(rotation=5)

    fig.suptitle("Test Performance" + " in " + env) if env is not None else fig.suptitle("Test Performance")
    plt.tight_layout()
    if show:
        plt.show()

def star_plot(reports, algos, show=True):
    '''
    Takes in the report for each RL algorithm, and creates a starplot.
    The starplot show the performance metrics for a single simulation environment:
        - Progress [0-100%]
        - Collision avoidance [0-100%]
        - Time consumption [steps] or [100-0%], where 10.000 steps is the max, or 100%
    '''

    # Format data to plot
    attributes = ["Avg. Progress", "No Collisions", "Avg. Timesteps"]
    values = []
    titles = [algo.upper() for algo in reports]

    # Helper variables for the plot structure
    labels = ["Path progress", "Collision avoidance", "Time consumption"]
    assert len(labels) == len(attributes)
    points = len(labels)
    angles = np.linspace(0, 2 * np.pi, points, endpoint=False).tolist()
    angles += angles[:1]  # Return to zero

    # Helper function
    def add_to_star(algo, color, label=None):
        # Fetch the performance attributes for ALGO in the report
        values = [reports[algo][0][attr] for attr in attributes]
        values += values[:1]
        if label != None:
            ax.plot(angles, values, color=color, linewidth=1, label=label)
        else:
            ax.plot(angles, values, color=color, linewidth=1, label=algo.upper())
        ax.fill(angles, values, color=color, alpha=0.25)

    ## Create plot object
    fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))
    ## Plot a new diamond with the add_to_star function
    add_to_star("ppo", '#1aaf6c')
    add_to_star("ddpg", '#429bf4')
    add_to_star("td3", '#d42cea')
    add_to_star("sac", '#fa8638')

    ## Fix axis to star from top
    ax.set_theta_offset(np.pi / 2)
    ax.set_theta_direction(-1)
    ## Edit x axis labels
    for label, angle in zip(ax.get_xticklabels(), angles):
        if angle in (0, np.pi):
            label.set_horizontalalignment('center')
        elif 0 < angle < np.pi:
            label.set_horizontalalignment('left')
        else:
            label.set_horizontalalignment('right')
    ## Customize your graphic
    # Change the location of the gridlines or remove them
    #ax.set_rscale('symlog')
    ax.set_rmax(100)
    ax.set_rgrids([20, 40, 60, 80])
    ax.set_yticklabels(["20%", "40%", "60%", "80%"])
    # ax.set_rgrids([]) # This removes grid lines
    # Change the color of the ticks
    ax.tick_params(colors='#222222')
    # Make the y-axis labels larger, smaller, or remove by setting fontsize
    ax.tick_params(axis='y', labelsize=10)
    # Make the x-axis labels larger or smaller.
    ax.tick_params(axis='x', labelsize=13)
    # Change the color of the circular gridlines.
    ax.grid(color='#AAAAAA')
    # Change the color of the outer circle
    ax.spines['polar'].set_color('#222222')
    # Change the circle background color
    ax.set_facecolor('#FAFAFA')
    # Add title and legend
    ax.set_title('Performance metric per algorithm in ENV', y=1.08)
    ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))
    # Draw axis lines for each angle and label.
    ax.set_thetagrids(np.degrees(angles), labels)

    plt.show()
    return

def radar_factory(num_vars, frame='circle'):
    """
    Create a radar chart with `num_vars` axes.

    This function creates a RadarAxes projection and registers it.

    Parameters
    ----------
    num_vars : int
        Number of variables for radar chart.
    frame : {'circle', 'polygon'}
        Shape of frame surrounding axes.

    """
    import matplotlib.pyplot as plt
    from matplotlib.patches import Circle, RegularPolygon
    from matplotlib.path import Path
    from matplotlib.projections.polar import PolarAxes
    from matplotlib.projections import register_projection
    from matplotlib.spines import Spine
    from matplotlib.transforms import Affine2D

    # calculate evenly-spaced axis angles
    theta = np.linspace(0, 2*np.pi, num_vars, endpoint=False)

    class RadarAxes(PolarAxes):

        name = 'radar'
        # use 1 line segment to connect specified points
        RESOLUTION = 1

        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            # rotate plot such that the first axis is at the top
            self.set_theta_zero_location('N')

        def fill(self, *args, closed=True, **kwargs):
            """Override fill so that line is closed by default"""
            return super().fill(closed=closed, *args, **kwargs)

        def plot(self, *args, **kwargs):
            """Override plot so that line is closed by default"""
            lines = super().plot(*args, **kwargs)
            for line in lines:
                self._close_line(line)

        def _close_line(self, line):
            x, y = line.get_data()
            # FIXME: markers at x[0], y[0] get doubled-up
            if x[0] != x[-1]:
                x = np.append(x, x[0])
                y = np.append(y, y[0])
                line.set_data(x, y)

        def set_varlabels(self, labels, fontsize='medium'):
            self.set_thetagrids(np.degrees(theta), labels, fontsize=fontsize)

        def _gen_axes_patch(self):
            # The Axes patch must be centered at (0.5, 0.5) and of radius 0.5
            # in axes coordinates.
            if frame == 'circle':
                return Circle((0.5, 0.5), 0.5)
            elif frame == 'polygon':
                return RegularPolygon((0.5, 0.5), num_vars,
                                      radius=.5, edgecolor="k")
            else:
                raise ValueError("Unknown value for 'frame': %s" % frame)

        def _gen_axes_spines(self):
            if frame == 'circle':
                return super()._gen_axes_spines()
            elif frame == 'polygon':
                # spine_type must be 'left'/'right'/'top'/'bottom'/'circle'.
                spine = Spine(axes=self,
                              spine_type='circle',
                              path=Path.unit_regular_polygon(num_vars))
                # unit_regular_polygon gives a polygon of radius 1 centered at
                # (0, 0) but we want a polygon of radius 0.5 centered at (0.5,
                # 0.5) in axes coordinates.
                spine.set_transform(Affine2D().scale(.5).translate(.5, .5)
                                    + self.transAxes)
                return {'polar': spine}
            else:
                raise ValueError("Unknown value for 'frame': %s" % frame)

    register_projection(RadarAxes)
    return theta

def radar_plot2(reports, algos, label=None):
    N = 4
    theta = radar_factory(N, frame='circle')

    # Format data to plot
    attributes = ["Avg. Progress", "No Collisions", "Avg. Cross-Track Error", "Avg. Timesteps"]
    values = []
    titles = [algo.upper() for algo in reports]

    # Helper variables for the plot structure
    #spoke_labels = ["Path progress", "Collision \n avoidance", "Cross-Track \n Error", "Time \n consumption"]
    spoke_labels = ["Path progress", "Colav", "CTE", "Timesteps"]
    assert len(spoke_labels) == len(attributes)


    # Helper function
    def get_values(algo, env):
        # Fetch the performance attributes for ALGO in the report
        values = [reports[algo][env][attr] for attr in attributes]
        #values += values[:1]
        return values

    envs = [0,1,2,3]
    env_names = ["MovingObstaclesNoRules", "Trondheim", "Agdenes", "Sorbuoya"]

    env_data = lambda _env : [(algo, get_values(algo, _env)) for algo in ["ppo", "ddpg", "td3", "sac"]]
    data = [(env_names[_env], env_data(_env)) for _env in envs]

    fig, axs = plt.subplots(figsize=(9, 9), nrows=2, ncols=2,
                            subplot_kw=dict(projection='radar'))
    fig.subplots_adjust(wspace=0.6, hspace=0.20, top=0.85, bottom=0.05)

    colors = ['#1aaf6c', '#429bf4', '#d42cea', '#fa8638']
    # Plot the four cases from the example data on separate axes
    for ax, (title, case_data) in zip(axs.flat, data):
        ax.set_title(title, weight='bold', size='medium', position=(0.5, 1.1),
                     horizontalalignment='center', verticalalignment='center')
        for (_algo, d), color in zip(case_data, colors):
            print("Plotting", title, _algo, "in", color, "color, and data is", d)
            ax.plot(theta, d, color=color, linewidth=1, label=_algo.upper())
            ax.fill(theta, d, facecolor=color, alpha=0.15)
        ax.set_varlabels(spoke_labels)
        ax.grid(color='#AAAAAA')
        ax.set_rgrids([(10 * (i + 1)) for i in range(10)])
        ax.set_yticklabels(["20%", "", "40%", "", "60%", "", "80%", "", "100%", ""])  # Offset makes this look more correct.
        ax.set_rlim(0, 100)
        ax.set_rlabel_position(315)
        # Change the color of the outer circle
        ax.spines['polar'].set_color('#222222')
        # Change the circle background color
        ax.set_facecolor('#FAFAFA')

        for label, angle in zip(ax.get_xticklabels(), theta):
            if angle in (0, np.pi):
                label.set_horizontalalignment('center')
            elif 0 < angle < np.pi:
                label.set_horizontalalignment('right')
            else:
                label.set_horizontalalignment('left')

    # add legend relative to top-left plot
    legend = axs[0, 1].legend(loc=(0.9, .95),
                              labelspacing=0.1, fontsize='small')

    fig.text(0.5, 0.965, 'Performance analysis of task-specific metrics across simulation environments',
             horizontalalignment='center', color='black', weight='bold',
             size='large')

    plt.show()

def radar_plot(reports, algos, label=None):
    # Format data to plot
    attributes = ["Avg. Progress", "No Collisions", "Avg. Timesteps"]
    values = []
    titles = [algo.upper() for algo in reports]

    # Helper variables for the plot structure
    #spoke_labels = ["Path progress", "Collision \n avoidance", "Time \n consumption"]
    spoke_labels = ["Path progress", "Colav", "Timesteps"]
    assert len(spoke_labels) == len(attributes)

    # Helper function
    def get_values(algo, env):
        # Fetch the performance attributes for ALGO in the report
        #values = [reports[algo][env][attr] if attr != "Avg. Timesteps" else 100 - (100 * reports[algo][env][attr] / 10000) for attr in attributes]
        values = [reports[algo][env][attr] for attr in attributes]
        #values += values[:1]
        return values

    envs = [0,1,2,3]
    env_names = ["MovingObstaclesNoRules", "Trondheim", "Agdenes", "Sorbuoya"]

    env_data = lambda _env : [(algo, get_values(algo, _env)) for algo in ["ppo", "ddpg", "td3", "sac"]]
    data = [(env_names[_env], env_data(_env)) for _env in envs]

    N = len(attributes)
    theta = radar_factory(N, frame='circle')

    fig, axs = plt.subplots(figsize=(9, 9), nrows=2, ncols=2,
                            subplot_kw=dict(projection='radar'))
    fig.subplots_adjust(wspace=0.6, hspace=0.20, top=0.85, bottom=0.05)

    colors = ['#1aaf6c', '#429bf4', '#d42cea', '#fa8638']
    # Plot the four cases from the example data on separate axes
    for ax, (title, case_data) in zip(axs.flat, data):
        ax.set_title(title, weight='bold', size='medium', position=(0.5, 1.1),
                     horizontalalignment='center', verticalalignment='center')
        for (_algo, d), color in zip(case_data, colors):
            print("Plotting", title, _algo, "in", color, "color, and data is", d)
            ax.plot(theta, d, color=color, linewidth=1, label=_algo.upper())
            ax.fill(theta, d, facecolor=color, alpha=0.15)

        ax.set_varlabels(spoke_labels)
        ax.set_rgrids([(10 * (i)) for i in range(1,11)])
        ax.set_yticklabels(["20%", "", "40%", "", "60%", "", "80%", "", "100%", ""])  # Offset makes this look more correct.
        ax.set_rlim(0, 100)
        ax.set_rlabel_position(315)
        ax.grid(color='#AAAAAA')
        # Change the color of the outer circle
        ax.spines['polar'].set_color('#222222')
        # Change the circle background color
        ax.set_facecolor('#FAFAFA')

        for label, angle in zip(ax.get_xticklabels(), theta):
            if angle in (0, np.pi):
                label.set_horizontalalignment('center')
            elif 0 < angle < np.pi:
                label.set_horizontalalignment('right')
            else:
                label.set_horizontalalignment('left')

    # add legend relative to top-left plot
    labels = set(algos)
    legend = axs[0, 1].legend(loc=(0.9, .95),
                              labelspacing=0.1, fontsize='small')

    fig.text(0.5, 0.965, 'Performance analysis of task-specific metrics across simulation environments',
             horizontalalignment='center', color='black', weight='bold',
             size='large')

    plt.show()

def radar_plot_6envs(reports, attributes, labels=None):
    # Format data to plot
    plt.style.use('ggplot')
    plt.rc('font', family='serif')
    # plt.rc('font', family='serif', serif='Times')
    # plt.rc('text', usetex=True)
    plt.rc('xtick', labelsize=8)
    plt.rc('ytick', labelsize=8)
    plt.rc('axes', labelsize=8)
    plt.axis('scaled')


    # Helper variables for the plot structure
    spoke_labels = labels if labels is not None else attributes  # ["Path progress", "Colav", "Timesteps"]
    assert len(spoke_labels) == len(attributes)

    # Helper function
    def get_values(algo, env):
        # Fetch the performance attributes for ALGO in the report
        values = [reports[algo][env][attr] for attr in attributes]
        return values

    envs = [0,1,2,3,4,5]
    env_names = ["Env0", "Env1", "Env2", "Env3", "Env4", "MovingObstaclesNoRules"]

    env_data = lambda _env : [(algo, get_values(algo, _env)) for algo in ["ppo", "ddpg", "td3", "sac"]]
    data = [(env_names[_env], env_data(_env)) for _env in envs]

    N = len(attributes)
    theta = radar_factory(N, frame='circle')

    fig, axs = plt.subplots(figsize=(11,11), nrows=3, ncols=2, subplot_kw=dict(projection='radar'))  # (11,11) for 3 attr, (14.5,13) for 4 attr
    fig.subplots_adjust(left=0.07, bottom=0, right=0.93, top=0.95, wspace=0.4, hspace=0)
    #fig.subplots_adjust(left=0.07, bottom=0, right=0.93, top=0.95, wspace=0.4, hspace=0.1)  # 4 attributes

    colors = ['#1aaf6c', '#429bf4', '#d42cea', '#fa8638']
    linestyles = ['solid', 'dotted', 'dashed', 'dashdot']
    #linestyles = ['solid', 'solid', 'solid', 'solid']
    # Plot the four cases from the example data on separate axes
    for ax, (title, case_data) in zip(axs.flat, data):
        ax.set_title(title, weight='medium', size=13, position=(0.5, 1.1),
                     horizontalalignment='center', verticalalignment='center')
        for (_algo, d), color, line in zip(case_data, colors, linestyles):
            print("Plotting", title, _algo, "in", color, "color, and data is", d)
            ax.plot(theta, d, color=color, linestyle=line, linewidth=2, label=_algo.upper())
            ax.fill(theta, d, facecolor=color, alpha=0.1)

        ax.set_varlabels(spoke_labels, fontsize=11)
        ax.set_rgrids([(10 * (i)) for i in range(1,11)])
        ax.set_yticklabels(["", "20%", "", "40%", "", "60%", "", "80%", "", "100%"], fontsize=11)  # Offset makes this look more correct.
        ax.set_rlim(0, 100)
        ax.set_rlabel_position(315)
        ax.grid(color='#AAAAAA')
        # Change the color of the outer circle
        ax.spines['polar'].set_color('#222222')
        # Change the circle background color
        ax.set_facecolor('#FAFAFA')

        for label, angle in zip(ax.get_xticklabels(), theta):
            if angle in (0, np.pi):
                label.set_horizontalalignment('center')
            elif 0 < angle < np.pi:
                label.set_horizontalalignment('right')
            else:
                label.set_horizontalalignment('left')

    # add legend relative to top-left plot
    legend = axs[0, 0].legend(loc=(1.05, .85),
                              labelspacing=0.1, fontsize='medium')

    #fig.text(0.5, 0.965, 'Performance analysis of task-specific metrics across simulation environments',
    #         horizontalalignment='center', color='black', weight='bold',
    #         size='large')

    plt.show()

def radar_plot_general(reports, attributes, labels=None):
    # Format data to plot
    plt.style.use('ggplot')
    plt.rc('font', family='serif')
    # plt.rc('font', family='serif', serif='Times')
    # plt.rc('text', usetex=True)
    plt.rc('xtick', labelsize=8)
    plt.rc('ytick', labelsize=8)
    plt.rc('axes', labelsize=8)
    plt.axis('scaled')


    # Helper variables for the plot structure
    spoke_labels = labels if labels is not None else attributes  # ["Path progress", "Colav", "Timesteps"]
    assert len(spoke_labels) == len(attributes)

    # Helper function
    def get_values(algo, env):
        # Fetch the performance attributes for ALGO in the report
        values = [reports[algo][env][attr] for attr in attributes]
        return values

    envs = [0,1,2,3]
    env_names = ["MovingObstaclesNoRules", "Trondheim", "Agdenes", "Sorbuoya"]

    env_data = lambda _env : [(algo, get_values(algo, _env)) for algo in ["ppo", "ddpg", "td3", "sac"]]
    data = [(env_names[_env], env_data(_env)) for _env in envs]

    N = len(attributes)
    theta = radar_factory(N, frame='circle')

    fig, axs = plt.subplots(figsize=(11,11), nrows=2, ncols=2, subplot_kw=dict(projection='radar'))  # (11,11) for 3 attr, (14.5,13) for 4 attr
    fig.subplots_adjust(left=0.07, bottom=0, right=0.93, top=0.95, wspace=0.4, hspace=0)
    #fig.subplots_adjust(left=0.07, bottom=0, right=0.93, top=0.95, wspace=0.4, hspace=0.1)  # 4 attributes

    colors = ['#1aaf6c', '#429bf4', '#d42cea', '#fa8638']
    linestyles = ['solid', 'dotted', 'dashed', 'dashdot']
    #linestyles = ['solid', 'solid', 'solid', 'solid']
    # Plot the four cases from the example data on separate axes
    for ax, (title, case_data) in zip(axs.flat, data):
        ax.set_title(title, weight='medium', size=13, position=(0.5, 1.1),
                     horizontalalignment='center', verticalalignment='center')
        for (_algo, d), color, line in zip(case_data, colors, linestyles):
            print("Plotting", title, _algo, "in", color, "color, and data is", d)
            ax.plot(theta, d, color=color, linestyle=line, linewidth=2, label=_algo.upper())
            ax.fill(theta, d, facecolor=color, alpha=0.1)

        ax.set_varlabels(spoke_labels, fontsize=11)
        ax.set_rgrids([(10 * (i)) for i in range(1,11)])
        ax.set_yticklabels(["", "20%", "", "40%", "", "60%", "", "80%", "", "100%"], fontsize=11)  # Offset makes this look more correct.
        ax.set_rlim(0, 100)
        ax.set_rlabel_position(315)
        ax.grid(color='#AAAAAA')
        # Change the color of the outer circle
        ax.spines['polar'].set_color('#222222')
        # Change the circle background color
        ax.set_facecolor('#FAFAFA')

        for label, angle in zip(ax.get_xticklabels(), theta):
            if angle in (0, np.pi):
                label.set_horizontalalignment('center')
            elif 0 < angle < np.pi:
                label.set_horizontalalignment('right')
            else:
                label.set_horizontalalignment('left')

    # add legend relative to top-left plot
    legend = axs[0, 0].legend(loc=(1.05, .85),
                              labelspacing=0.1, fontsize='medium')

    #fig.text(0.5, 0.965, 'Performance analysis of task-specific metrics across simulation environments',
    #         horizontalalignment='center', color='black', weight='bold',
    #         size='large')

    plt.show()


ENVIRONMENTS = ["Env0-v0", "Env1-v0", "Env2-v0", "Env3-v0", "Env4-v0", "MovingObstaclesNoRules-v0",
                "Trondheim-v0", "Agdenes-v0", "Sorbuoya-v0"]
#ALGORITHMS = ["a2c", "acktr", "ddpg", "td3", "ppo", "sac"]
ALGORITHMS = ["ppo", "ddpg", "td3", "sac"]
ATTRIBUTES = ["Episodes", "Avg. Reward", "Std. Reward", "Avg. Progress", "Avg. Collisions", "No Collisions",
              "Avg. Cross-Track Error", "Avg. Timesteps", "Avg. Duration", "Avg. Pathlength",
              "Avg. Speed", "Max. Speed"]

# Colormap for color blind people
CB_color_cycle = ['#377eb8', '#ff7f00', '#4daf4a',
                  '#f781bf', '#a65628', '#984ea3',
                  '#999999', '#e41a1c', '#dede00']

if __name__ == '__main__':
    import glob, os
    import matplotlib as mpl
    import matplotlib.pyplot as plt

    mpl.rcParams['pdf.fonttype'] = 42  ## TrueType fonts
    mpl.rcParams['ps.fonttype'] = 42
    mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=CB_color_cycle)

    test_data = True
    convert_percentages = True # Formats metrics to intervals 0-100%

    reports_per_algo = {}
    fig, ax = plt.subplots(figsize=((10,5)))
    for algorithm in ALGORITHMS:
        print("Processing algorithm ", algorithm, ": ", sep="")
        reports = []
        envs = []

        for env in ENVIRONMENTS:

            if test_data:
                base_path = "../logs/tests/{}/".format(env)
            else:  # Training performace
                base_path = "../logs/figures/{}/".format(env)

            if not os.path.exists(base_path):
                print("\t{} not trained, skipping".format(env))
            else:
                print("\t{}".format(env))

            agent = [os.path.basename(x) for x in glob.glob(base_path + "*" + algorithm)]
            # If multiple agents trained with selected algorithm and environment, select one.
            if len(agent) > 1:
                #print("Multiple agents found:", agent)
                #print("Select from indices:", [i for i in range(len(agent))])
                try:
                    #idx = int(input(""))
                    idx = len(agent)-1  # Just take the last one for now
                    agent = agent[idx]
                except ValueError:
                    print("Index out of range, exiting")
            elif len(agent) == 0:  # Algorithm has not been applied to this environment yet, skip
                continue  # to next algorithm
            else:  # Only one agent found:
                agent = agent[0]

            # Determine path to report file:
            #path = "../logs/figures/{}/{}/report.txt".format(env, agent)
            path = base_path + agent + "/report.txt"

            # Read report
            report = read_report(path, convert_percentages=convert_percentages)
            report["Environment"] = env  # Add environment to report
            report["Performance"] = performance(report)
            # Store report and the corresponding environment
            reports.append(report)

        reports_per_algo[algorithm] = reports

        # Plot attribute

        plot_attribute_per_env(ax, algorithm, reports, attributes="Avg. Progress")
        print("")
    plt.show()

    plot_progress_vs_env(reports_per_algo, show=True)

    #plot_attribute_per_algo(reports_per_algo, show=True)

    #star_plot(reports_per_algo, ["PPO", "DDPG", "TD3", "SAC"])

    #radar_plot(reports_per_algo, ["PPO", "DDPG", "TD3", "SAC"])
    #radar_plot2(reports_per_algo, ["PPO", "DDPG", "TD3", "SAC"])

    # 4 attributes
    #radar_plot_general(reports_per_algo,
    #                   attributes=["Avg. Progress", "No Collisions", "Avg. Timesteps", "Avg. Cross-Track Error"],
    #                   labels=["Path Progression", "Collision \navoidance", "Time efficiency", "Path \nadherence"])

    # Path progression, collision avoidance and path adherence
    #radar_plot_general(reports_per_algo,
    #                   attributes=["Avg. Progress", "No Collisions", "Avg. Cross-Track Error"],
    #                   labels=["Path Progression", "Collision \navoidance", "Path \nadherence"])

    # Path adherence, collision avoidance and time efficiency
    radar_plot_general(reports_per_algo,
                       attributes=["Avg. Cross-Track Error", "No Collisions", "Avg. Timesteps"],
                       labels=["Path adherence", "Collision \navoidance", "Time \nefficiency"])
